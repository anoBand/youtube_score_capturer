내가 만든 서버를 amazon elastic beanstalk에 올려서 서버를 구축하고싶어 그런데 플랫폼이랑 서버를 어떻게 작성해야 할지 모르겠어.
구체적으로는 python과 flask를 백엔드로 사용하고 html, js를 프론트엔드로 사용하는데 yt-dlp로 유튜브 영상을 다운받고 opencv로 영상의 악보 이미지를 비교 및 자른 후 fpdf로 이미지를 병합한 최종 악보 pdf를 생성해. 소스코드는 작성을 했지만 웹 서비스를 위해 aws ec2, oracle을 사용해봤지만 문제가 생겨서 elastic beanstalk에 할 건데 이러면 어떻게 소스코드 및 디렉토리 구성을 해야 하는지 모르겠어

===

AWS Elastic Beanstalk에 Flask 앱을 배포하기 위한 구조와 설정을 도와드리겠습니다.

디렉토리 구조
먼저 다음과 같은 디렉토리 구조를 권장합니다:

---
# AWS Elastic Beanstalk Flask 프로젝트 구조

```
your-project/
├── application.py          # 메인 Flask 앱 (반드시 이 이름!)
├── requirements.txt        # Python 의존성
├── .ebextensions/         # Beanstalk 설정 (옵션)
│   └── python.config
├── static/                # 정적 파일 (CSS, JS, 이미지)
│   ├── css/
│   ├── js/
│   └── uploads/          # 업로드된 파일 임시 저장
├── templates/             # HTML 템플릿
│   └── index.html
├── modules/               # 커스텀 모듈
│   ├── __init__.py
│   ├── youtube_downloader.py
│   ├── image_processor.py
│   └── pdf_generator.py
└── temp/                  # 임시 파일 저장소
```

## 핵심 파일들

### 1. application.py (메인 앱)
```python
import os
import tempfile
from flask import Flask, request, render_template, send_file, jsonify
from werkzeug.utils import secure_filename
import uuid

# 커스텀 모듈 임포트
from modules.youtube_downloader import download_youtube_video
from modules.image_processor import process_video_frames
from modules.pdf_generator import create_pdf_from_images

# Flask 앱 생성 (Beanstalk에서는 application 변수명 필요)
application = Flask(__name__)
app = application

# 설정
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB
app.config['UPLOAD_FOLDER'] = '/tmp'  # Beanstalk에서는 /tmp 사용

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/process', methods=['POST'])
def process_video():
    try:
        youtube_url = request.json.get('youtube_url')
        
        # 임시 디렉토리 생성
        temp_dir = tempfile.mkdtemp()
        
        # 1. 유튜브 영상 다운로드
        video_path = download_youtube_video(youtube_url, temp_dir)
        
        # 2. OpenCV로 영상 프레임 처리
        processed_images = process_video_frames(video_path, temp_dir)
        
        # 3. PDF 생성
        pdf_path = create_pdf_from_images(processed_images, temp_dir)
        
        # 4. 파일 전송
        return send_file(pdf_path, as_attachment=True, 
                        download_name='sheet_music.pdf')
                        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    # 로컬 테스트용
    app.run(debug=True)
```

### 2. requirements.txt
```txt
Flask==2.3.3
yt-dlp==2023.7.6
opencv-python-headless==4.8.0.76
fpdf2==2.7.5
Pillow==10.0.0
numpy==1.24.3
requests==2.31.0
```

### 3. .ebextensions/python.config (시스템 패키지 설치)
```yaml
packages:
  yum:
    ffmpeg: []
    git: []

commands:
  01_make_temp_dir:
    command: "mkdir -p /tmp && chmod 755 /tmp"
```

## 모듈 예시

### modules/youtube_downloader.py
```python
import yt_dlp
import os

def download_youtube_video(url, output_dir):
    """유튜브 영상 다운로드"""
    ydl_opts = {
        'format': 'best[height<=720]',  # 메모리 절약을 위해 720p 제한
        'outtmpl': os.path.join(output_dir, '%(title)s.%(ext)s'),
    }
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        filename = ydl.prepare_filename(info)
        return filename
```

### modules/image_processor.py
```python
import cv2
import os

def process_video_frames(video_path, output_dir):
    """OpenCV로 영상에서 악보 이미지 추출 및 처리"""
    cap = cv2.VideoCapture(video_path)
    processed_images = []
    frame_count = 0
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break
            
        # 여기에 악보 감지 및 자르기 로직 구현
        # 예시: 간단한 프레임 저장
        if frame_count % 30 == 0:  # 1초마다 프레임 추출 (30fps 가정)
            img_path = os.path.join(output_dir, f'frame_{frame_count}.jpg')
            cv2.imwrite(img_path, frame)
            processed_images.append(img_path)
            
        frame_count += 1
    
    cap.release()
    return processed_images
```

### modules/pdf_generator.py
```python
from fpdf import FPDF
from PIL import Image
import os

def create_pdf_from_images(image_paths, output_dir):
    """이미지들을 PDF로 병합"""
    pdf = FPDF()
    
    for img_path in image_paths:
        # 이미지 크기 확인
        with Image.open(img_path) as img:
            width, height = img.size
            
        # PDF 페이지 추가
        pdf.add_page()
        
        # 이미지를 PDF 크기에 맞게 조정
        pdf_width = 210  # A4 width in mm
        pdf_height = 297  # A4 height in mm
        
        # 비율 유지하며 크기 조정
        img_ratio = width / height
        if img_ratio > pdf_width / pdf_height:
            img_width = pdf_width
            img_height = pdf_width / img_ratio
        else:
            img_height = pdf_height
            img_width = pdf_height * img_ratio
            
        pdf.image(img_path, 0, 0, img_width, img_height)
    
    pdf_path = os.path.join(output_dir, 'sheet_music.pdf')
    pdf.output(pdf_path)
    return pdf_path
```

## 배포 단계

### 1. 코드 준비
```bash
# 프로젝트 디렉토리로 이동
cd your-project

# ZIP 파일 생성 (Beanstalk 배포용)
zip -r myapp.zip . -x "*.git*" "__pycache__/*" "*.pyc"
```

### 2. Beanstalk 설정
- AWS 콘솔에서 Elastic Beanstalk 서비스 접속
- "새 애플리케이션 생성" 클릭
- 플랫폼: **Python**
- 플랫폼 브랜치: **Python 3.11**
- 플랫폼 버전: 최신 버전 선택
- 애플리케이션 코드: 위에서 만든 ZIP 파일 업로드

### 3. 환경 설정
배포 후 구성 > 소프트웨어에서:
- **환경 속성**에 필요한 환경 변수 추가
- **인스턴스 유형**: 최소 t3.medium 이상 (OpenCV, 영상 처리용)

## 주의사항

### 메모리 및 성능
- Elastic Beanstalk의 기본 t2.micro는 메모리가 부족할 수 있음
- 영상 처리 작업이 있으므로 t3.medium 이상 권장
- 큰 파일 처리시 타임아웃 설정 조정 필요

### 파일 시스템
- `/tmp` 디렉토리 사용 (Beanstalk에서 쓰기 가능)
- 임시 파일 정리 로직 추가 필요
- 업로드 파일 크기 제한 설정

### 보안
- YouTube URL 검증 로직 추가
- 파일 업로드 보안 검증
- CORS 설정 (필요시)

이 구조로 시작하시면 Beanstalk에 성공적으로 배포할 수 있을 것입니다. 구체적인 에러나 추가 질문이 있으시면 말씀해 주세요!
---

추가로 몇 가지 중요한 팁을 드리겠습니다:

배포 전 확인사항
메인 파일명: 반드시 application.py로 명명해야 합니다. Beanstalk은 이 파일을 자동으로 찾습니다.
WSGI 변수: Flask 앱 변수를 application으로 설정해야 합니다:
python
application = Flask(__name__)
app = application  # 편의를 위한 별칭
시스템 패키지: OpenCV와 yt-dlp가 시스템 라이브러리(ffmpeg 등)에 의존하므로 .ebextensions/python.config 파일이 중요합니다.
성능 최적화 권장사항
인스턴스 타입: t3.medium 이상 (RAM 4GB+)
타임아웃 설정: 긴 영상 처리를 위해 300초 이상
임시 파일 정리: 각 요청 후 /tmp 디렉토리 정리
문제 해결 시 확인할 점
로그 확인: Beanstalk 콘솔에서 로그 다운로드
헬스체크: / 경로가 정상 응답하는지 확인
의존성: requirements.txt의 버전 호환성
혹시 기존 코드가 있으시다면 해당 코드를 보여주시면 더 구체적인 조언을 드릴 수 있습니다!